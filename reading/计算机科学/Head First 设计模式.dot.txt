digraph g{
	"Head First 设计模式"->{设计模式入门,观察者模式,工厂模式}
	设计模式入门->"以往是代码复用，设计模式是经验复用"
	设计模式入门->模拟鸭子
	设计模式入门->找出应用中可能需要变化之处->抽出变化的部分->分开变化和不会变化的部分
	设计模式入门->针对接口编程，而不是针对实现编程
	设计模式入门->多用组合，少用继承
	设计模式入门->策略模式
	设计模式入门->{00基础,00原则,00模式}

	观察者模式->定义观察者模式
	观察者模式->松耦合
	观察者模式->"案例 - 气象站"
	观察者模式->"Java 内置的观察者模式"->"Observable 的确定"
	观察者模式->"观察者模式 00基础,00原则,00模式"

	装饰着模式->{"案例 - 咖啡店","开闭原则","定义装饰着模式","Java I/O","装饰着模式 00基础,00原则,00模式"}
	工厂模式->{"new 操作符",定义简单工厂,创建者和产品,定义工厂方法模式","案例 - 比萨店","依赖倒置原则","原料工厂","定义抽象工厂","工厂模式 00基础,00原则,00模式"}



	单件模式->{"巧克力工厂",多线程与单件,"单件模式 00基础,00原则,00模式"}
	单件模式->确保一个类只有一个实例，并提供一个全局访问点


	命令模式->从餐厅到命名模式
	命令模式->"将 “请求” 封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销操作"

	适配器模式与外观模式->从餐厅到命名模式
	适配器模式与外观模式->定义适配器模式->将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间
	适配器模式与外观模式->定义外观模式->提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用
	适配器模式与外观模式->最少知识原则

	模板方法->定义模板方法->在一个方法中定义一个算法的框架，而将一些步骤延迟到子类中。
	模板方法->好莱坞原则
	模板方法->模板方法与策略
	迭代器与组合模式->提供一种方法顺序访问一个聚合对象中的各个元素，而不是暴露其内部的表示
	迭代器与组合模式->单一责任->一个类只有一个引起变化的原因
	迭代器与组合模式->迭代器与集合


	迭代器与组合模式->定义组合模式->允许你将对象组合成树形结构来表现 “整体/部分” 层次结构。

	迭代器与组合模式->{组合迭代器,空迭代器}

	状态模式->定义状态模式->允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。



	代理模式->目标是为监视器编码
	代理模式->定义：为另一个对象提供一个替身或占位符以控制对这个对象的访问


	复合模式 
	与设计模式相处->模式->在某情境下，针对某问题的某种解决方案->{情境,问题,解决方案}

	情境->应用某个模式的情况

	问题->在某情景下达到的目标，或某情境下的约束
	解决方案->一个通用的设计，用来解决约束、达到目标

	与设计模式相处->组织设计模式->模式分类->{创建型,行为型,结构型}

	组织设计模式->针对分类->{类,对象}

	与设计模式相处->{用模式思考,共享词汇}

	与设计模式相处->相关书籍->"《The Timeless Way of Building》,\l《A Pattern Language》"
	与设计模式相处->其它在线资源

	附录A->剩下的模式->{桥接,生成器,责任链,蝇量,解释器,中介者,备忘录,原型,访问者}

}