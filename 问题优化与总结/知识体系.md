# Android 高级工程师知识体系
## 1 通信
数据与二进制
- 字长
  [字长](http://www.cnblogs.com/chakyu/p/7405275.html)
- 字节与字符编码
《The Unicode® Standard Version 9.0 》
[unicode 及位置](https://unicode-table.com/en/#control-character)
- 涉及类
  1. [Character.UnicodeBlock](https://en.wikipedia.org/wiki/Unicode_block)

- [Unicode与UTF-8转化](https://zh.wikipedia.org/wiki/UTF-8)
- [UTF-16](https://en.wikipedia.org/wiki/UTF-16)
  超过三个字节 Unicode 用四个字节的UTF-16编码
  
```
  System.out.println("a".getBytes(StandardCharsets.UTF_16).length);//结果为4，是因为加上BOM(字节顺序标记(ByteOrderMark))，用FEFF表示，FEFF占用两个字节。
```

  大端，高位字节存储在内存地址的低位地址
  
```
    0x CC AA 88 66

   Big-Endian
   +--------+--------+-------+--------+
   |  CC    |  AA    |  88   |  66    |
   |        |        |       |        |
   +--------+--------+-------+--------+

   Little-Endian
   +--------+--------+-------+--------+
   |  66    |  88    |  AA   |  CC    |
   |        |        |       |        |
   +--------+--------+-------+--------+
```

## 2 Java 基础
> 《Core Java》（延展阅读《C Primer Plus》《C++ Primer》）

### 基本数据类型
- Short
Short.MIN_VALUE ~ Short.MAX_VALUE
=-2^15~（2^15）-1
=-32768~-32767（计数单位约3万）

Android 资源65534问题

- Integer
Integer.MIN_VALUE ~ Integer.MAX_VALUE
=-2^31~（2^31）-1
=-2_147_483_648 ~ 2_147_483_647(计数单位约等于21亿)

- Long
Long.MIN_VALUE ~ Long.MAX_VALUE
==-2^63~（2^63）-1
=-9_223_372_036_854_775_808L~-9_223_372_036_854_775_807L
（计数单位约等于922京）


- Float （遵循IEEE-754格式标准）

```
第一步：[176.0625换成二进制数](https://blog.csdn.net/crjmail/article/details/79723051)，
整数部分采用"除2取余，逆序排列"法：
小数点前:176 / 2 = 88  
余数为 088 / 2=44 余数为 0                             
44 / 2 =22    余数为 0                       
22 / 2= 11    余数为 0                              
11 / 2 =5     余数为 1        
5 / 2=2       余数为 1                             
2/ 2  =1      余数为 0                                                                             
1/ 2=0        余数为 1    商为0，结束。                                                                       
小数点前整数转换为二进制:10110000    
---------------------  
 
小数部分采用 "乘2取整，顺序排列"法部分：
0.0625 * 2 = 0.125   整数为0                 
0.125 * 2 = 0.25     整数为0             
0.25* 2 = 0.50       整数为0             
0.5* 2 = 1.0         整数为1，小数部分为0,结束
小数点后整数转换为二进制:0001 

得到二进制位：10110000.0001 

第二步：在换算成内存格式（IEEE-754格式标准）  SEEEEEEE    EMMMMMMM    MMMMMMMM    MMMMMMMM
S 0正数，1负数
E 第一位（1：大于1的十进制，0：0~1之间的十进制）
即 0 10000110 0110000 00010000 00000000

```
-Float.MAX_VALUE ~ Float.MAX_VALUE
=[-3.40282346638528860e+38 , -1.40129846432481707e-45] ∪ [1.40129846432481707e-45 ~ 3.40282346638528860e+38]
正负是对称的，看下正数部分
Float.MIN_VALUE ~ Float.MAX_VALUE
=2^(-126) ~~ 2(1-2^(-24)) * 2^(2^7-1)
=2^(-126) ~~ 2(1-2^(-24)) * 2^(127)
=1.1754943508223e-38 ~ 3.4e+38
= （已知e-24位 涅槃寂静） ~ 3.4*(10^38)(计数单位约等于34涧)

- Double
内存里的存储结构（IEEE-754格式标准）：SEEE EEEE EEEE MMMM MMMM MMMM MMMM MMMM MMMM MMMM MMMM MMMM MMMM MMMM MMMM MMMM
正数范围：
2^(-1022-52) ~~ 2-2^-52)*(2^((2^10)-1))

- Char
  jdk 9采用压缩字符串，都是 Iso-8891，使用一个字节，否则用 UTF-16 编码。

- Boolean
- Byte

### 变量与常量


### 2.1 Collection 类（List, Queue, Map）

```text
                         +--------------+                                          +----------------+
                         |              |                                          |                |
                         |   Collection |                                          |     Map        |
                         +------+-------+                                          +-------^--------+
                                ^                                                     +-----------------------+
        +---------------------------------------------+                               |                       |
        |                       |                     |                             .....                  ......
+-------+-------+        +------+------+       +------+-----+                 +--------------+         +------------+
|               |        |             |       |            |                 |              |         |            |
|   Set         |        |   List      |       |    Queue   |                 | HashMap      |         |  SortMap   |
+------+--------+        +-----+-------+       +-------+----+                 +-------+------+         +-------+----+
       ^                       ^                       ^                              ^                        ^
     ..^..                     | <---------------------+                              |                        |
       |                     ....                      |                              |                        |
+------+--------+  +-----------+  +---------+    +-----+-----------+         +--------+--------+        +------+------+
|               |  |           |  |         |    |                 |         |                 |        |             |
|   HashSet     |  | ArrayList |  | Vector  |    |   LinkedList    |         |   LinkedHashMap |        |   TreeMap   |
+---------------+  +-----------+  +---------+    +-----------------+         +-----------------+        +-------------+


```
#### Array
Arrays.sort 双轴快排算法（包含归并排序算法，经典快速排序算法，插入排序算法混用，及**jdk 1.7**废弃掉的归并排序和插入排序混用）
#### HashTable
开放地址法解决Hash冲突
#### HashMap
- 自动扩容机制
容量(Capacity)和负载因子(Load factor)
自动扩容原来2倍
threshold = (newCapacity >> 1) + (newCapacity >> 2); // 3/4 capacity

- 哈希碰撞
hash bucket 大小设置为 length=2^n。
2^n-1对应的二进制 1111...111，hash bucket的索引值是通过 hash & (tab.length - 1)，设置为2^n，减少哈希碰撞

哈希碰碰撞时的解决方法
1. 开放地址法（HashTable），包括 线性探测再散列，二次探测再散列，伪随机探测再散列
2. 链地址法（HashMap 用红黑树代替链表，加快搜索）
3. 再哈希法
4. 建立一个公共溢出区
- 树化
  TREEIFY_THRESHOLD = 8时，对哈希冲突链地址树化
#### TreeMap
红黑树平衡调整
二叉树搜索

#### SortedMap
Charset#availableCharsets():SortedMap

#### LinkedHashMap

LinkedHashMap节点类 LinkedHashMapEntry 包含 before, after;
HashMap节点类 Node 包好 next;

### 2.2 泛型，反射，注解
- 泛型：Generics in Java is similar to templates in C++.
集合容器和网络请求经常用到

动态代理


 
### 2.3 流（IO, NIO）
字符与字节
UTF-8 
RandomAccessFile

BUffer,Channel ,Selector
### 2.4 多线程与并发
- 多线程
  
  线程池：ThreadPoolExecutor
    - 任务队列 SynchronousQueue,LinkedBlockingDeque（常用）,ArrayBlockingQueue
    - 任务 FutureTask（get方法会阻塞，知道FutureTask执行结束）,Callable,
- 并发是为了提高效率，减少时间，引入多线程实现并发，同时多线程带来些问题，包括共享变量，锁活跃性问题(死锁,饥饿、活锁) ,性能问题

- 死锁
    
    - 静态的锁顺序死锁。一个线程执行a方法且已经获得了A锁，在等待B锁；另一个线程执行了b方法且已经获得了B锁，在等待A锁。这种状态，就是发生了静态的锁顺序死锁。
    - [动态的锁顺序死锁](https://www.androidos.net.cn/codebook/AndroidRoad/java/concurrence/deadlock.md)
    ```java
    //可能发生动态锁顺序死锁的代码
    class DynamicLockOrderDeadLock {
        public void transefMoney(Account fromAccount, Account toAccount, Double amount) {
            synchronized (fromAccount) {
                synchronized (toAccount) {
                    //...
                    fromAccount.minus(amount);
                    toAccount.add(amount);
                    //...
                }
            }
        }
    }
    ```

    -  协作对象之间发生的死锁
- volatile。保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。在某些情况下性能要优于synchronized，但对变量的写操作不依赖于当前值。
- 内置的锁 synchronized，可重入非公平锁（是独占锁，是一种悲观锁），会导致饥饿效应，不可中断
- 重入锁 ReentrantLock（内部通过 AbstractQueuedSynchronizer实现公平锁和非公平锁，AbstractQueuedSynchronizer包含Condition），解决复杂锁问题，如先获得锁A，然后再获取锁B，当获取锁B后释放锁A同时获取锁C，当锁C获取后，再释放锁B同时获取锁D。
- 生产者与消费者。Condition配合ReentrantLock，实现了wait()/notify()
- 乐观锁思想-CAS原子操作。修改前，对比直到共享内存和当前值（当前线程临时内存）一致，才做修改，这个流程不会加锁阻塞
    - AtomicStampedReference来解决ABA问题；
    - 循环时间长开销大
    - AtomicReference类来保证引用对象之间的原子性
    
- 并发集合 ArrayBlockingQueue,LinkedBlockingQueue,
    - ConcurrentHashMap。有并发要求，使用该类替换HashTable
### 面向对象与设计模式
 五大基本原则：单一职责原则（接口隔离原则），开放封闭原则，Liskov替换原则，依赖倒置原则，良性依赖原则

- 创建型
  - 构建者模式
  
  Notification，AlertDialog，StringBuilder 和StringBuffer，OKhttp构建Request，Glide

  - 单例模式
  
  Application，LayoutInflater 
  - 工厂方法
  
  BitmapFactory
  - 原型模式
  - 抽象工厂
- 结构型
  - 适配器模式（Adapter）
  - 装饰模式（Retrofit）
  - 享元模式

    Message.obtainMessage
  - 代理模式

    静态代理：封装ImageLoader、Glide；动态代理：面向切面。AIDL
  - 组合模式

    View和ViewGroup的组合

  - 外观模式
   
    ContextImpl
  - 桥接模式

    Window和WindowManager之间的关系
- 行为型
  - 命令模式
    
    EventBus，Handler.post后Handler.handleMessage
  - 观察者模式
  
    RxAndroid，BaseAdapter.registerDataSetObserver
  - 模板方法
  - 策略模式

    时间插值器，如LinearInterpolator
  - 状态模式
  - 责任链

    对事件的分发处理，很多启动弹窗
  - 备忘录模式

    onSaveInstanceState和onRestoreInstanceState
  - 迭代器模式（集合迭代器）
  - 解释器模式

    PackageParser
  - 访问者模式
  - 中介者模式

    Binder机制
### Java虚拟机
对象的创建
Java内存区域与内存模型
Java类加载机制及类加载器
Java垃圾回收算法及垃圾收集器
JVM判断对象是否已死



### 2.5 C语言，汇编及CPU处理二进制

## 3 Android 基础

### 3.1  Android 系统体系

应用层，framework层，libs和Runtime层，内核层
#### 应用层
- 四大组件，Fragment

- Handler 消息机制
- AsyncTask
    
    容器类：ArrayDeque，LinkedBlockingQueue（ThreadPoolExecutor的线程队列）
    并发类：ThreadPoolExecutor（包含 ThreadFactory属性，用于创建线程），AtomicBoolean，AtomicInteger，FutureTask(包含Callable属性，任务执行的时候调用Callable#call,执行AsyncTask#dobackgroud)
- HandlerThread
- IntentService
- LruCache
- 窗口（Window，Activity，DecorView以及ViewRoot）
- View 测量，布局及绘制

- 进程通信
AIDL
文件
- Bitmap

- 动画
1. 补间动画
   烟花效果
2. 视图动画（Rotate,Scale,translate,alpha）
   箭头动画
   启动图片放大动画
   弹窗动画
3. 属性动画，插值器（Interpolator）和估值器（TypeEvaluator）
   估值器自定义滑动效果
4. Viewpager转化动画
5. SVG动画
6. Activity转场动画
7. Camera 3D动画
8. AR沉浸式效果（ARCore）

- 图形及用户界面
1. 界面及事件
2. openGl
   
- Context

- 持久化和序列化（Parcelable，Serializable）

### 3.2 Android 开发模式

#### 性能优化总结
- 渲染速度
    1. 布局优化（include merge, viewstub）
    分析工具，不必要不加载（include merge, viewstub），ConstaintLayout，Lint
    1. 绘制优化
    尽量用Drawable
    1. 响应速度优化
    2. ListView/RecycleView及Bitmap优化
    3. 线程优化
- 内存优化
- 电量消耗
    3.内存泄漏优化
        3.1 单例
        3.2 非静态内部类
        3.3 资源未关闭（webview没执行 destroy）
        3.4 ListView 未缓存
        3.5 集合类未销毁

- 其他性能优化的建议

#### 内存泄漏
 
#### 架构之模块化（插件化及组件化）
插件化
- Dynamic-loader-apk
- Replugin

组件化
- 组件间解耦
  1. AAC 
   ViewModel LiveData
  2. MVP DI框架Dagger2解耦
- 通信
1. 对象持有
2. 接口持有
3. 路由 （ARouter）
   Dagger2 依赖注入控制反转，

#### apk安装过程

#### 推送
- MQTT
1.  最核心的传输协议 Subcribe（定阅）和Publish（推送）
2. QoS（定阅等级）
   
- XMPP
1.  OpenFire管理服务器
2.  asmack包提供协议支持
3.  XMPP通信原语有3种：message、presence和iq

#### 直播
- 腾讯云直播（互动直播，收费）
1.  环境初始化与销毁
2.  房间初始化与销毁，声音控制
3.  上麦推流，下麦拉流
   
- 即构（互动视频）
1.  环境初始化与销毁
2.  房间初始化与销毁，声音控制
3.  推流和拉流

#### popupwindow 与 Dialog
- popupwindow 非阻塞浮层
- Dialog 阻塞式对话框
### 3.3 开源框架
#### OkHttp

#### Retrofit

#### RPC

#### EventBus
反射与注解


#### ARouter
控制反转和面向切面

#### FLutter

## 4 算法与数据结构
KNUTH -《The Art of Computer Programming》基本算法，排序与搜索，半数值计算，组合算法（枚举与回溯-图论-最优化与递归），造句算法
- 线性表
- 栈和队列
- 树
- 图
- 散列查找
- 排序
- 海量数据
- 堆
  PriorityQueue
- 线性同余随机算法
- HashMap hash冲突链表的红黑树平衡算法
- 二叉查找树
  1. AVL平衡树
    1.1 其根的左右子树高度之差的绝对值不能超过1

  2. 红黑平衡树
    2.1 每一个节点不是红色的就是黑色的
    2.2. 根总是黑色的
    2.3. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定成立）
    2.4. 从根到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点。

## 6 计算机网络
- TCP/IP
- HTTP/HTTPS
http2.0支持长连接
## 7 操作系统
参考 Brian Ward,《How Linux works - what every superuser should know》[M].No Starch Press(2014)

7.1 用户进程
7.2 内核（进程，内存，设备驱动，系统调用 System Call）
7.3 硬件（CPU，内存，磁盘，网络端口 ）

## 8 数据库与SQL
三大范式

事务 ACID

### Sql 
- 多表查询（内连接，外连接）
- 嵌套查询
  与IN、ALL、ANY、EXISTS配合使用。
- 派生表查询
```sql
SELECT * FROM student,(
    SELECT sno FROM SC WHERE cno=1//派生查询
) AS tempSC
WHERE student.sno = tempSC.sno

```
- 集合查询
  UNION、UNION ALL、INTERSECT、EXCEPT